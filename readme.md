# RTS

Приложение регистрирует участников сореврования и устанавливает лучшее время круга 
при участии в гонке.

В процессе используются два RFID считывателя и EPC-метки. Участник прислоняет
свою метку к портативному считывателю и в приложении всплывает окно регистрации участника.
Администратор приложения регистрирует участника и далее, главный считыватель 
расположенный на гоночной трассе присылает в приложение метки (если он активирован),
по которым и считаются результаты гонки для каждого зарегистрированного участника.

### Установка и запуск

#### Установи зависимости
`npm install`

#### Собери проект
`npm run build`

#### Запусти приложение
`npm start`

#### Как вносить изменения
Если меняется клиентская часть: .css и .js файлы, то достаточно закрыть приложение
и запустить заново командой `npm start`. Если меняется бэкенд .ts файлы, надо пересобирать,
можно командой `npm run br`

#### Симуляция приёмников
Если у тебя нет двух китайских Chafon CF-RU6403 R2000 и UHF Reader 09 то в консоли приложения 
специально для тебя можно набрать `fakePortableTag()` чтобы симулировать приход метки для портативного 
приёмника и `fakeMainTag()` для главного. В качестве аргумента можно передать свой уникальный uid.

## TODO:
- Перетащить доки и либы по оборудованию в проект
- Адаптировать index.ts под перезагрузку окна. Неудобно каждый раз закрывать приложение
и пересобирать. Удобно обновляя клиентский код жать CTRL+R и получать тот же результат
что при перезагрузке приложения
- Добавить описание процесса сборки .NET core приложений
- Найти решения консольной сборки .NET приложений, для того чтобы не нужно было
открывать Visual Studio

## База данных:
- Если не ставится sqlite3:
https://stackoverflow.com/questions/32504307/how-to-use-sqlite3-module-with-electron

- Работа с базой SQLite Database Browser одновременно с работающим приложением может
влиять на результат выполнения программы. Не следует открывать соединения с БД из двух 
программ одновременно. 

## По архитектуре и рефакторингу
- Пока сложно представить что из себя будет представлять приложение и придерживаться какой-то
жесткой структуры программы. Кажется что всякие функции типа updateUsersView не должны содержать 
в себе стрельбу событиями в клиентскую часть, события на клиент должны посылаться только из контроллера. 
